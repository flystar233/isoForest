set.seed(1)
cluster1 <- data.frame(
x = rnorm(1000, -1, .4),
y = rnorm(1000, -1, .2)
)
cluster2 <- data.frame(
x = rnorm(1000, +1, .2),
y = rnorm(1000, +1, .4)
)
outlier <- data.frame(
x = -1,
y =  1
)
### Putting them together
X <- rbind(cluster1, cluster2, outlier)
set.seed(1071)
X <- rnorm( 500, 0, 1)
Y <- rnorm( 500, 0, 1)
replace_x <- sample(1:500, 20 )
replace_y <- sample(1:500, 50 )
X[replace_x] <- rnorm(20, mean = 3, sd = 2)
Y[replace_y] <- rnorm(50, mean = -4, sd = 1.5)
anomaly_indicator <- rep(0,500)
anomaly_indicator[replace_x] <- 1
anomaly_indicator[replace_y] <- 1
anomaly_indicator <- as.factor(anomaly_indicator)
test_data <- data.frame(X, Y, anomaly_indicator)
plot(test_data$X,test_data$Y)
View(test_data)
ggplot(test_data, aes(x = X, y = Y, fill = anomaly_indicator)) +geom_raster()
library(ggplot2)
ggplot(test_data, aes(x = X, y = Y, fill = anomaly_indicator)) +geom_raster()
set.seed(1)
cluster1 <- data.frame(
x = rnorm(1000, -1, .4),
y = rnorm(1000, -1, .2)
)
cluster2 <- data.frame(
x = rnorm(1000, +1, .2),
y = rnorm(1000, +1, .4)
)
outlier <- data.frame(
x = -1,
y =  1
)
### Putting them together
X <- rbind(cluster1, cluster2, outlier)
X
X$z=1
X
ggplot(X, aes(x = x, y = y, fill = z)) +geom_raster()
faithfuld
data= faithfuld
plot(data$eruptions,data$waiting)
x_cont <- seq(10, 50, length.out = 100 )
x_cont
y_cont <- seq(1, 10, length.out = 100 )
y_cont
new_grid <- data.frame( expand.grid(x_cont, y_cont ) )
new_grid
set.seed(1071)
X <- rnorm( 500, 0, 1)
Y <- rnorm( 500, 0, 1)
replace_x <- sample(1:500, 20 )
replace_y <- sample(1:500, 50 )
X[replace_x] <- rnorm(20, mean = 3, sd = 2)
Y[replace_y] <- rnorm(50, mean = -4, sd = 1.5)
anomaly_indicator <- rep(0,500)
anomaly_indicator[replace_x] <- 1
anomaly_indicator[replace_y] <- 1
anomaly_indicator <- as.factor(anomaly_indicator)
X
y
Y
data <- data.frame(cbind(X,Y))
x_index <- 1
y_index <- 2
data
means <- t(colMeans(data[,-c( x_index, y_index )]))
means
var_names <- colnames( data )
x.min <- min(unlist(X), na.rm = TRUE)
y.min <- min(unlist(Y), na.rm = TRUE)
x.max <- max(unlist(X), na.rm = TRUE)
y.max <- max(unlist(Y), na.rm = TRUE)
x_cont <- seq(x.min, x.max, length.out = 100 )
y_cont <- seq(y.min, y.max, length.out = 100 )
x_cont
new_grid <- data.frame( expand.grid(x_cont, y_cont ) )
new_grid
data <- data.frame( new_grid, means)
colnames(data) <- var_names
data
scored=1
scored=0
data_fm <- data.frame( cbind( data, scored))
data_fm
colnames(data_fm) <- c("x","y","scores")
ggplot(data_fm, aes(x,y)) +
geom_raster(aes(fill = scores))
anomaly_plot <- function( x,
y,
scores = NULL,
data = NULL,
forest = NULL,
x.min= NULL,
x.max = NULL,
y.min = NULL,
y.max = NULL,
contour = FALSE,
palette_contour = NULL,
# spectral c( "#E6F598", "#FDAE61", "#F46D43", "#9E0142" )
contamination = 0.05 )
{
if(is.character(x)){
x_index <- grep( pattern = x, x = colnames(data) )
x <- data[,which( x == colnames(data))]
}
if(is.character(y)){
y_index <- grep( pattern = y, x = colnames(data) )
y <- data[,which( y == colnames(data))]
}
if(contour == FALSE ){
if(is.null(data)){
data <- cbind(x,y)
}
if(is.null(scores)){
scores <- predict.isolationForest(forest, data)
}
Anomalies <- as.factor(scores > quantile(scores,(1-contamination), na.rm = TRUE))
levels(Anomalies) <- c("Normal","Anomaly")
data <- data.frame(x,y)
colnames(data) <- c("x","y")
data_fm <- data.frame( cbind( data,
Anomalies))
ggplot2::ggplot(data_fm, ggplot2::aes( x, y, colour = Anomalies, shape = Anomalies)) +
ggplot2::geom_point(size = 1.9) +
ggplot2::scale_colour_manual(name = "Scoring", values = c("#2554C7","#E42217")) +
ggplot2::scale_shape_manual(name = "Scoring", values = c(15,17)) +
ggplot2::xlab("X") +
ggplot2::ylab("Y") +
ggplot2::theme(
axis.title.y = ggplot2::element_text( angle = 0, vjust = 0.5, size = 12),
axis.title.x = ggplot2::element_text( size = 12) )
}
else{
# contour
if(is.character(x)){
x_index <- grep( pattern = x, x = colnames(data) )
x <- data[,which( x == colnames(data))]
}
if(is.character(y)){
y_index <- grep( pattern = y, x = colnames(data) )
y <- data[,which( y == colnames(data))]
}
if(is.null(x.min)){
x.min <- min(unlist(x), na.rm = TRUE)
}
if(is.null(y.min)){
y.min <- min(unlist(y), na.rm = TRUE)
}
if(is.null(x.max)){
x.max <- max(unlist(x), na.rm = TRUE)
}
if(is.null(y.max)){
y.max <- max(unlist(y), na.rm = TRUE)
}
if(is.null(data)){
data <- data.frame(cbind(x,y))
x_index <- 1
y_index <- 2
}
# get column means for later
means <- t(colMeans(data[,-c( x_index, y_index )]))
var_names <- colnames( data )
# define the grid on which the contour will be plotted
x_cont <- seq(x.min, x.max, length.out = 100 )
y_cont <- seq(y.min, y.max, length.out = 100 )
new_grid <- data.frame( expand.grid(x_cont, y_cont ) )
data <- data.frame( new_grid, means)
colnames(data) <- var_names
# predict scores for the grid of data
scored <- predict.isolationForest(forest, data)
data_fm <- data.frame( cbind( data, scored))
colnames(data_fm) <- c("x","y","scores")
if(is.null(palette_contour)){
palette_contour <- c( "#F5793A","#A95AA1","#85C0F9","#0F2080")
}
ggplot2::ggplot(data_fm, ggplot2::aes( x = x, y = y, z = scores)) +
ggplot2::geom_raster(ggplot2::aes(fill = scores), interpolate = TRUE) +
ggplot2::guides(fill = ggplot2::guide_colorbar(title = "Anomaly Score")) +
ggplot2::scale_fill_gradientn(colours = palette_contour) +
ggplot2::xlab("X") +
ggplot2::ylab("Y") +
ggplot2::theme(
axis.title.y = ggplot2::element_text( angle = 0, vjust = 0.5, size = 12),
axis.title.x = ggplot2::element_text( size = 12) )
}
}
anomaly_plot(x=X,y=Y)
anomaly_plot(x=X,y=Y,scores = data_fm$scores)
anomaly_plot(x=X,y=Y,scores = data_fm$scores,contour=T)
anomaly_plot <- function( x,
y,
scores = NULL,
data = NULL,
forest = NULL,
x.min= NULL,
x.max = NULL,
y.min = NULL,
y.max = NULL,
contour = FALSE,
palette_contour = NULL,
# spectral c( "#E6F598", "#FDAE61", "#F46D43", "#9E0142" )
contamination = 0.05 )
{
if(is.character(x)){
x_index <- grep( pattern = x, x = colnames(data) )
x <- data[,which( x == colnames(data))]
}
if(is.character(y)){
y_index <- grep( pattern = y, x = colnames(data) )
y <- data[,which( y == colnames(data))]
}
if(contour == FALSE ){
if(is.null(data)){
data <- cbind(x,y)
}
if(is.null(scores)){
scores <- predict.isolationForest(forest, data)
}
Anomalies <- as.factor(scores > quantile(scores,(1-contamination), na.rm = TRUE))
levels(Anomalies) <- c("Normal","Anomaly")
data <- data.frame(x,y)
colnames(data) <- c("x","y")
data_fm <- data.frame( cbind( data,
Anomalies))
ggplot2::ggplot(data_fm, ggplot2::aes( x, y, colour = Anomalies, shape = Anomalies)) +
ggplot2::geom_point(size = 1.9) +
ggplot2::scale_colour_manual(name = "Scoring", values = c("#2554C7","#E42217")) +
ggplot2::scale_shape_manual(name = "Scoring", values = c(15,17)) +
ggplot2::xlab("X") +
ggplot2::ylab("Y") +
ggplot2::theme(
axis.title.y = ggplot2::element_text( angle = 0, vjust = 0.5, size = 12),
axis.title.x = ggplot2::element_text( size = 12) )
}
else{
# contour
if(is.character(x)){
x_index <- grep( pattern = x, x = colnames(data) )
x <- data[,which( x == colnames(data))]
}
if(is.character(y)){
y_index <- grep( pattern = y, x = colnames(data) )
y <- data[,which( y == colnames(data))]
}
if(is.null(x.min)){
x.min <- min(unlist(x), na.rm = TRUE)
}
if(is.null(y.min)){
y.min <- min(unlist(y), na.rm = TRUE)
}
if(is.null(x.max)){
x.max <- max(unlist(x), na.rm = TRUE)
}
if(is.null(y.max)){
y.max <- max(unlist(y), na.rm = TRUE)
}
if(is.null(data)){
data <- data.frame(cbind(x,y))
x_index <- 1
y_index <- 2
}
# get column means for later
means <- t(colMeans(data[,-c( x_index, y_index )]))
var_names <- colnames( data )
# define the grid on which the contour will be plotted
x_cont <- seq(x.min, x.max, length.out = 100 )
y_cont <- seq(y.min, y.max, length.out = 100 )
new_grid <- data.frame( expand.grid(x_cont, y_cont ) )
data <- data.frame( new_grid, means)
colnames(data) <- var_names
# predict scores for the grid of data
data_fm <- data.frame( cbind( data, scored))
colnames(data_fm) <- c("x","y","scores")
if(is.null(palette_contour)){
palette_contour <- c( "#F5793A","#A95AA1","#85C0F9","#0F2080")
}
ggplot2::ggplot(data_fm, ggplot2::aes( x = x, y = y, z = scores)) +
ggplot2::geom_raster(ggplot2::aes(fill = scores), interpolate = TRUE) +
ggplot2::guides(fill = ggplot2::guide_colorbar(title = "Anomaly Score")) +
ggplot2::scale_fill_gradientn(colours = palette_contour) +
ggplot2::xlab("X") +
ggplot2::ylab("Y") +
ggplot2::theme(
axis.title.y = ggplot2::element_text( angle = 0, vjust = 0.5, size = 12),
axis.title.x = ggplot2::element_text( size = 12) )
}
}
anomaly_plot(x=X,y=Y,scores = data_fm$scores,contour=T)
setwd("~/GitHub/isoForest/R")
source('isoForest.r')
source('method.r')
source('terminal.nodes.r')
source('terminal_nodes.r')
library(ranger)
data <- iris[1:2]
data
result <- isoForest(data)
anomaly_plot(x=data$Sepal.Length,y=data$Sepal.Width,scores =result$anomaly_score ,contour=T)
result$anomaly_score
anomaly_plot(x=data$Sepal.Length,y=data$Sepal.Width,scores =result$anomaly_score ,contour=F)
result$anomaly_score[1,]=0.99999
result$anomaly_score[1]=0.99999
anomaly_plot(x=data$Sepal.Length,y=data$Sepal.Width,scores =result$anomaly_score ,contour=F)
anomaly_plot(x=data$Sepal.Length,y=data$Sepal.Width,scores =result$anomaly_score ,contour=T)
calculate_depth_per_tree <- function(df) {
# Find the leaf nodes
leaf_nodes <- which(df$terminal)
# Pre-allocate memory
leaf_depth <- data.frame(nodeID = df$nodeID[leaf_nodes], depth = integer(length(leaf_nodes)))
# Create a lookup table for parent nodes
parent_lookup <- match(df$nodeID, c(df$leftChild, df$rightChild))
# Iterate over each leaf node
for (i in seq_along(leaf_nodes)) {
depth <- 0
current_node <- leaf_nodes[i]
# Traverse upwards until the root node (nodeID == 0)
while (df$nodeID[current_node] != 0) {
# Find the parent node of the current node
parent_node <- parent_lookup[current_node]
# If no parent node is found, the data might be incorrect
if (is.na(parent_node)) {
stop("Error: No parent node found for nodeID ", df$nodeID[current_node])
}
# Update the current node to the parent node and increase the distance
current_node <- parent_node
depth <- depth + 1
}
# Store the calculated distance in the data frame
leaf_depth$depth[i] <- depth
}
return(leaf_depth)
}
library(ranger)
calculate_depth_per_tree()
rf <- ranger(Species ~ ., data = iris)
calculate_depth_per_tree(treeInfo(rf, 1))
calculate_depth_per_tree <- function(df) {
# Store the nodeID of each leaf node and its distance to the root node
leaf_nodes <- which(df$terminal)
leaf_depth <- matrix(NA, nrow = length(leaf_nodes), ncol = 2)
colnames(leaf_depth) <- c("nodeID", "depth")
# Iterate over each row of the data frame
for (i in seq_along(leaf_nodes)) {
# If it's a leaf node (terminal == TRUE)
if (df$terminal[leaf_nodes[i]]) {
depth <- 0
current_node <- leaf_nodes[i]
# Traverse upwards until the root node (nodeID == 0)
while (df$nodeID[current_node] != 0) {
# Find the parent node of the current node
parent_node <- which(df$leftChild == df$nodeID[current_node] | df$rightChild == df$nodeID[current_node])
# If no parent node is found, the data might be incorrect
if (length(parent_node) == 0) {
stop("Error: No parent node found for nodeID ", df$nodeID[current_node])
}
# Update the current node to the parent node and increase the distance
current_node <- parent_node
depth <- depth + 1
}
# Store the calculated distance and nodeID in the matrix
leaf_depth[i, "nodeID"] <- df$nodeID[leaf_nodes[i]]
leaf_depth[i, "depth"] <- depth
}
}
return(leaf_depth)
}
calculate_depth_per_tree(treeInfo(rf, 1))
calculate_depth_per_tree(treeInfo(rf, 1))
calculate_depth_per_tree(treeInfo(rf, 1))
calculate_depth_per_tree(treeInfo(rf, 2))
calculate_depth_per_tree(treeInfo(rf, 4))
calculate_depth_per_tree2 <- function(df) {
# Store the nodeID of each leaf node and its distance to the root node
leaf_depth <- data.frame(nodeID = integer(), depth = integer())
# Iterate over each row of the data frame
for (i in seq_len(nrow(df))) {
# If it's a leaf node (terminal == TRUE)
if (df$terminal[i]) {
depth <- 0
current_node <- i
# Traverse upwards until the root node (nodeID == 0)
while (df$nodeID[current_node] != 0) {
# Find the parent node of the current node
parent_node <- which(df$leftChild == df$nodeID[current_node] | df$rightChild == df$nodeID[current_node])
# If no parent node is found, the data might be incorrect
if (length(parent_node) == 0) {
stop("Error: No parent node found for nodeID ", df$nodeID[current_node])
}
# Update the current node to the parent node and increase the distance
current_node <- parent_node
depth <- depth + 1
}
# Store the calculated distance and nodeID in the data frame
leaf_depth <- rbind(leaf_depth, data.frame(nodeID = df$nodeID[i], depth = depth))
}
}
return(leaf_depth)
}
calculate_depth_per_tree2(treeInfo(rf, 4))
calculate_depth_per_tree2(treeInfo(rf, 1))
calculate_depth_per_tree2(treeInfo(rf, 2))
calculate_depth_per_tree2(treeInfo(rf, 3))
calculate_depth_per_tree2(treeInfo(rf, 4))
calculate_depth_per_tree(treeInfo(rf, 4))
